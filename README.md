[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18362559&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

## Part 1: Introduction to Software Engineering

### Explain what software engineering is and discuss its importance in the technology industry.
- _Software engineering_ is a systematic approach that involves applying engineering principles when creating a software so as to ensure the final product, our software, is reliable, efficient and meets the needs of our users.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Importance of Software Engineering in the Technology Industry.</ins>
- Software Engineering practices ensure that the software is of high quality, reliable and works as it is intended to.
- A software that is well engineered gives room for scalability to accomodate growing users and additional features which is very essential for businesses that plan to expand over time.
- By focusing on user requirements and usability of the software, software engineering ensures that the end product does meet the needs and expectations of its users.
- Software engineering emphasizes on the need to write maintanable code which makes it easier to update, fix and improve the software over time.
- The testing and validation step in the SDLC assist in identifying and mitigating risks in its development cycle before being moved into production.


### Identify and describe at least three key milestones in the evolution of software engineering.
1. _The Introduction of High-Level Programming Languages (1950s)._
   - The development of high-level programming languages signifies a huge milestone in the evolution os software engineering as this brought about the transition from low-level programming languages (i.e. Assembly), which were only machine-readable. But with the introduction of the high-level programming languages (i.e. FORTRAN, COBOL, ALGO) allowed us to write code that is more human-readable and understandable.

2. _The Birth of Software Engineering (1968)._
   - In 1968, NATO held a conference that brought together over 50 experts in the software development industry. At this time, software development was perceived as an ad hoc process where devs primarily focused on functional requirements. This brought in the need for a more structured approach since software systems were becoming increasingly complex that the need for reliable and maintainable systems became a major concern. Attendees of the NATO conference recognized the need for a more disciplined approach to software development and maintenance of which they proposed the term "software engineering" to emphasize the importance of engineering principles and practices in software development.

3. _The Rise of Agile Methodologies (2001)._
   - The introduction of Agile Methodologies brought about a paradigm shift in software development practices. With methodologies such as Scrum and Extreme Programming (XP), they emphasized on iterative development, customer collaboration and responsiveness to change.


### List and briefly explain the phases of the Software Development Life Cycle.
+ _Requirement Analysis_ - This phase involves the gathering and analyzing the requirements of the system with the aim of understanding what the software needs to do and the problems it should solve. The information gathered is majorly obtained from stakeholders, clients, users and business analysts using various methods such as surveying, conducting interviews, asking them to fill questionnairs and so on. The deliverable in this phase is the Software Requirements Specification (SRS) document.
+ _System Design_ - Next is the design phase, where the architecture and design of the system are done with respect to the information gathered and analysed in the previous step. For the architecture, the diagrams are required while with the design, its the data schemas, APIs and UI & UX designs are needed. The deliverable in this phase is the System Design Specification (SDS) document.
+ _System Development/Implementation_ - Then comes the actual coding phase. This is the phase where the actual code is written based on the designs from the SDS document. The deliverable in this phase is the system's source code.
+ _System Testing_ - In the testing phase, rigorous testing and validation tests are done to ensure the system is safe, meets the specified requirements and that the system is free from bugs. Debugs are majorly done in this phase while testing the system/modules. Deliverables in this phase include test cases, test reports and bug logs.
+ _Deployment_ - In the deployemnt phase, the system is hosted on an online cloud or production environment which allows the system to be accessible to the right audience. Deliverable in this case is the deployed system.
+ _Maintenance_ - After deployment, the software enters the maintenance phase, where it is monitored, updated, and improved based on user feedback and changing requirements. An updated software version is the deliverable in this phase.
 

### Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
1. _Waterfall Methodology_ - This is a linear and sequential approach to software development where each phase of the SDLC must be completed before the next one begins. Works best when the project has stable requirements (_Government tax filling system_), when tackling short projets (_A company's website redesign_) and when dealing with highly regulated industries (_A software for monitoring patient's vitals_).
2. _Agile Methodology_ - This is an iterative and incremental approach to software development that emphasizes flexibility, customer collaboration, and the delivery of small, functional increments of the software. Works best when the project has dynamic requirements (_A startup mobile app for food delivery_), a customer-centric project (_E-Commerce software_) and complex projects (_Banking system_).

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Comparison</ins>
- Both methodologies encapases phases like planning, analysis, design, development, testing and deployment.
- Both waterfall and agile methodologies aim to deliver high-quality software that meets user requirements.
- Both methodologies emphasize on the importance of having documentation while designing and developing your software.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Contrast</ins>
- Waterfall uses a linear and sequential approach where each phase must be completed before moving onto the next phase while Agile uses an iterative and incremental approach meaning work is done in small repeatable cycles.
- Agile's focus emphasizes on working software and collaboration over extensive documentation while Waterfall's focus emphasizes thorough planning and documentation because each step needs to be completed before moving onto the next phase.
- Waterfall delivers only a single delivery at the end of the cycle, which is the actual working system whereas Agile does frequent deliveries (usually 2 to 4 weeks) of small, functional increments.
- While the user's involvement is limited (during requirement analysis and feedback during maintenance) in Waterfall, the same involvement is needed continously in Agile where user's are involved throughout the process for their feedback.
- In terms of flexibility, Waterfall has a rigid and inflexible approach where changes are difficult to accommodate once the project begins while Agile has a highly flexible approach that embraces change even late in the development cycle.


### Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
1. Software Developer:
   - Collaborate with stakeholders and users to understand and analyze software requirements and later translate the requirements into technical aspects.
   - Design software components and modules based on the analyzed requirements.
   - Write, compile and debug code in accordance to the design specification while still following best coding standards and best practices.
   - Perform unit testing to ensure each component is working as expected and testing the entire system as a whole.
   - Update and improve existing software based on user feedback and changing requirements and also optimize code for performance and scalability.
   - Work closely with other developers, QA engineers, and project managers and participate in code reviews.
2. Quality Assurance Engineer:
   - Develop test plans and strategies which are based on the software requirements.
   - Perform various types of testing including unit testing, functional testing, regression testing, performance testing, security testing and acceptance testing.
   - Collaborate with developers to resolve any identified issues.
   - Integrate automated tests into the continuous integration/continuous deployment (CI/CD) pipeline.
   - Ensure that all testing activities are well-documented for future reference.
3. Project Manager:
   - Develop project plans, including timelines, resources, and budgets as well as defining the project scope, goals and deliverables.
   - Coordinate activities across different roles, including developers, QA engineers, and other stakeholders.
   - Identify potential risks and develop mitigation strategies throughout the project's lifecycle.
   - Serve as the primary point of contact between the stakeholders and the developers.

### Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Importance of Integrated Development Environments (IDEs)</ins>
- _Code Editing:_ IDEs provide syntax highlighting which makes it easier for users to read and write code. Also, the auto completion and code suggestion features aid developers write code faster with limited errors.
- _Debugging:_ IDEs comes with built-in debuggers that highlight errors and issues in codes when a developer makes an error making it easier to identify and fix bugs.
- _Integration with Other Tools:_ Most IDEs are integrated with version controls such as git which allows developers to manage code changes directly from the IDE. Other IDEs such as VS code come with plugins and extensions that allows users to add additional functionalities.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Examples of IDEs</ins>
- Visual Studio Code
- Eclipse
- Vim
- Atom
- Sublime Text

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Importance of Version Control Systems (VCS)</ins>
- _Collaboration:_ Version Control systems allows multiple developers to work on the same project simultaneously without overwriting each other's changes.
- _Tracking Changes:_ VC systems usually maintains a history of all changes, making it easy to track who made what changes and when which is useful for auditing and understanding the evolution of the codebase.
- _Backup and Restore:_ Version Controls act as backup systems which ensure codes aren't lost. This feature allows developers to backup by pushing their codes online and restore their projects in case of an issue in the current version.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Examples of VCS</ins>
- Git
- GitHub
- GitLab


### What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Challenges</ins> </br>
1. Due to the evolving business needs, customer feedback, and market condition, requirements often change during the development process which can lead to project delays and scope creep.
2. Integrating different systems, modules, or third-party services can be complex and error-prone which can cause compatibility issues and system failures.
3. Software is often vulnerable to security threats such as hacking, data breaches, zero-day vulnerabilities and malware. This can compromise the integrity and confidentiality of user data.
4. Managing time effectively to meet deadlines while maintaining code quality can be challenging at time as more requirements can be brought forward.
5. The rapid pace of technological change requires continuous learning and adaptation.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Solutions</ins>
1. Adopt Agile practices which allow for iterative development and frequent reassessment of priorities.
2. To facilitate smooth integration, developers are adviced to use well-defined APIs and implement continuous integration (CI) practices.
3. Following security best practices, such as input validation, encryption, as well as conducting regular security audits and penetration testing can help identify and address bugs as well as vulnerabilities.
4. Prioritizing tasks based on their importance and urgency, using time tracking tools and breaking down large tasks into smaller manageable chunk are just but a few ways of managing time.
5. Practices such as participating in development communities, forums, doing online courses, attending workshops and conferences can help a developer stay up to tune with the trending technologies.


### Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
- _Unit Testing:_ This involves testing individual components (a function, a class, or a method) in isolation to ensure they are working accordingly.
- _Integration Testing:_ Integration testing focuses on verifying the interactions between different units or components of the software to ensure they work together as expected
- _System Testing:_ This is a type of testing that's performed in an environment that closely resembles the production environment and evaluates the system to ensure it meets the specified requirements.
- _Acceptance Testing:_ Acceptance testing is the final phase of testing, where the software is evaluated to ensure it is ready for deployment.

## Part 2: Introduction to AI and Prompt Engineering


### Define prompt engineering and discuss its importance in interacting with AI models.
- _Prompt Engineering_ is the process of refining an input, or rather a prompt, to effectively interact with an AI. The main goal of this being to get a more accurate, relevant and useful response from the AI agent.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <ins>Importance of Prompt Engineering</ins>
- A well-crafted prompt, as compared to a vague prompt, will in fact help the AI to understance the context of the query and provide a much accurate and relevant response.
- An effective prompt can stimulate the AI to generate creative ideas, solutions, and content that might not emerge with less refined inputs.
- A well-engineered prompt can make an interaction with AI more intuitive and user-friendly hence enhancing the overall user experience.
- Good prompt engineering minimizes the need for multiple iterations and follow-up questions, saving the user time and effort.

### Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
1. _Prompt 1:_ Explain the concept of prompt engineering.
2. _Prompt 2:_ You are a software engineer with expertise in AI. Explain prompt engineering to a non-technical audience, using simple language and analogies.

   - The second prompt is more likely to provide a clear and specific response tailored by the user. This is brought by the clarification of the audience, language to be used and the type of expertise the user is looking for (In this case, the AI is to act as a software engineer).
